{
  "metadata": {
    "title": "Cẩm nang An toàn Thông tin",
    "version": "8.0",
    "total_topics": 21,
    "total_questions": 420,
    "categories": ["Tấn công & Lỗ hổng", "Mật mã học", "Hạ tầng & Giao thức"]
  },
  "topics": [
    {
      "id": "topic-1",
      "title": "Return-to-libc Attack",
      "category": "Tấn công & Lỗ hổng",
      "content": {
        "summary": "Kỹ thuật khai thác lỗi tràn bộ đệm (buffer overflow) nâng cao, vượt qua cơ chế bảo vệ NX bit.",
        "details": [
          {
            "heading": "Nguyên lý",
            "text": "Thay vì chèn mã độc (shellcode) vào stack (nơi không có quyền thực thi), kẻ tấn công ghi đè địa chỉ trả về (return address) bằng địa chỉ của một hàm có sẵn trong thư viện libc (thường là hàm system())."
          },
          {
            "heading": "Kịch bản tấn công",
            "text": "1. Tìm địa chỉ hàm system() và chuỗi '/bin/sh' trong thư viện.\n2. Ghi đè Stack: [Padding] [Addr system] [Addr exit] [Addr '/bin/sh'].\n3. Khi hàm hiện tại trả về, CPU nhảy đến system('/bin/sh') -> Mở shell."
          },
          {
            "heading": "Phòng chống",
            "text": "- ASLR: Ngẫu nhiên hóa địa chỉ thư viện.\n- Stack Canaries: Phát hiện ghi đè stack.\n- ASCII Armoring: Chặn địa chỉ chứa null byte."
          }
        ]
      },
      "quiz": [
        {
          "q": "Cơ chế bảo mật nào thúc đẩy sự ra đời của Return-to-libc?",
          "options": [
            {"text": "ASLR (Address Space Layout Randomization)", "correct": false},
            {"text": "Stack Canaries", "correct": false},
            {"text": "NX bit (No-Execute) / DEP", "correct": true},
            {"text": "RELRO (Relocation Read-Only)", "correct": false}
          ],
          "explanation": "NX/DEP ngăn thực thi trên Stack, buộc phải tái sử dụng hàm sẵn có."
        },
        {
          "q": "Trong Ret2Libc trên x86, giá trị nào nằm ngay sau địa chỉ system() trên stack?",
          "options": [
            {"text": "Đối số của system (địa chỉ \"/bin/sh\")", "correct": false},
            {"text": "Địa chỉ trả về giả (thường exit)", "correct": true},
            {"text": "Địa chỉ cơ sở libc", "correct": false},
            {"text": "Saved EBP", "correct": false}
          ],
          "explanation": "Chuỗi payload: padding, &system, &exit, &\"/bin/sh\"."
        },
        {
          "q": "Vì sao Ret2Libc trên x64 phức tạp hơn x86?",
          "options": [
            {"text": "Không gian địa chỉ lớn hơn", "correct": false},
            {"text": "Tham số truyền qua thanh ghi (RDI, RSI...)", "correct": true},
            {"text": "Libc không được nạp", "correct": false},
            {"text": "Stack mã hóa phần cứng", "correct": false}
          ],
          "explanation": "Cần ROP gadgets để thiết lập thanh ghi tham số."
        },
        {
          "q": "Gadget ROP thiết yếu để truyền tham số đầu tiên trên Linux x64 là?",
          "options": [
            {"text": "pop rax; ret", "correct": false},
            {"text": "pop rdi; ret", "correct": true},
            {"text": "pop rsi; ret", "correct": false},
            {"text": "pop rbp; ret", "correct": false}
          ],
          "explanation": "Tham số đầu tiên nằm ở RDI theo System V ABI."
        },
        {
          "q": "Để vượt ASLR, điều kiện tiên quyết thường là gì?",
          "options": [
            {"text": "Quyền root", "correct": false},
            {"text": "Lỗ hổng rò rỉ thông tin (Information Leak)", "correct": true},
            {"text": "Mã nguồn đầy đủ", "correct": false},
            {"text": "Tắt firewall", "correct": false}
          ],
          "explanation": "Rò rỉ địa chỉ thực giúp tính base address libc."
        },
        {
          "q": "Hàm system() thực tế gọi chương trình nào?",
          "options": [
            {"text": "/bin/zsh", "correct": false},
            {"text": "/bin/sh", "correct": true},
            {"text": "Syscall trực tiếp", "correct": false},
            {"text": "cmd.exe", "correct": false}
          ],
          "explanation": "system gọi shell mặc định, thường là /bin/sh."
        },
        {
          "q": "Lệnh Assembly chuyển luồng thực thi theo địa chỉ trên đỉnh stack là?",
          "options": [
            {"text": "CALL", "correct": false},
            {"text": "JMP", "correct": false},
            {"text": "RET", "correct": true},
            {"text": "PUSH", "correct": false}
          ],
          "explanation": "RET lấy địa chỉ từ stack và nhảy đến đó."
        },
        {
          "q": "Khi ASLR bật, thành phần nào thay đổi qua mỗi lần chạy?",
          "options": [
            {"text": "Offset giữa system và \"/bin/sh\" trong libc", "correct": false},
            {"text": "Địa chỉ cơ sở (base) của libc trong bộ nhớ", "correct": true},
            {"text": "Opcode của system", "correct": false},
            {"text": "Cấu trúc stack frame", "correct": false}
          ],
          "explanation": "ASLR ngẫu nhiên hóa vị trí nạp thư viện."
        },
        {
          "q": "Chuỗi \"/bin/sh\" thường được tìm thấy ở đâu?",
          "options": [
            {"text": "Phải tự chèn vào stack", "correct": false},
            {"text": "Phân vùng dữ liệu của libc", "correct": true},
            {"text": "Tải từ server C2", "correct": false},
            {"text": "Trong biến môi trường", "correct": false}
          ],
          "explanation": "Libc chứa sẵn chuỗi \"/bin/sh\"."
        },
        {
          "q": "Yêu cầu căn chỉnh stack 16-byte thường liên quan đến chỉ thị nào?",
          "options": [
            {"text": "MOVAPS", "correct": true},
            {"text": "POP", "correct": false},
            {"text": "PUSH", "correct": false},
            {"text": "LEAVE", "correct": false}
          ],
          "explanation": "MOVAPS cần địa chỉ 16-byte aligned, sai gây segfault."
        },
        {
          "q": "Ret2Libc chuỗi cho phép thực hiện điều gì?",
          "options": [
            {"text": "Gọi liên tiếp nhiều hàm libc", "correct": true},
            {"text": "Chỉ gọi được một hàm", "correct": false},
            {"text": "Ghi đè file thực thi trên đĩa", "correct": false},
            {"text": "Thay đổi quyền file libc", "correct": false}
          ],
          "explanation": "Chuỗi gọi như setuid rồi system để leo đặc quyền."
        },
        {
          "q": "ASCII Armoring phòng chống bằng cách nào?",
          "options": [
            {"text": "Mã hóa toàn bộ libc", "correct": false},
            {"text": "Ánh xạ thư viện vào vùng địa chỉ có byte 0x00", "correct": true},
            {"text": "Xóa các hàm nguy hiểm", "correct": false},
            {"text": "Kiểm tra integrity stack", "correct": false}
          ],
          "explanation": "Byte 0x00 làm đứt các hàm sao chép chuỗi."
        },
        {
          "q": "Vai trò của GOT/PLT trong bối cảnh Ret2Libc?",
          "options": [
            {"text": "Lưu biến môi trường", "correct": false},
            {"text": "Cơ chế liên kết động để giải địa chỉ hàm", "correct": true},
            {"text": "Bảo vệ stack", "correct": false},
            {"text": "Mã hóa input", "correct": false}
          ],
          "explanation": "Có thể lợi dụng để tìm hoặc chuyển hướng địa chỉ hàm."
        },
        {
          "q": "Biện pháp hiệu quả bên cạnh ASLR để chặn Ret2Libc?",
          "options": [
            {"text": "Stack Canaries", "correct": false},
            {"text": "CFI (Control Flow Integrity)", "correct": true},
            {"text": "WAF", "correct": false},
            {"text": "Input Validation", "correct": false}
          ],
          "explanation": "CFI kiểm soát luồng gọi hàm, khó chuyển hướng trái phép."
        },
        {
          "q": "Không tìm thấy \"/bin/sh\" trong bộ nhớ thì làm gì?",
          "options": [
            {"text": "Bỏ cuộc", "correct": false},
            {"text": "Đưa chuỗi vào stack/heap qua input và dùng địa chỉ", "correct": true},
            {"text": "Dùng \"/bin/ls\"", "correct": false},
            {"text": "Ghi đè libc trên đĩa", "correct": false}
          ],
          "explanation": "Tự kiểm soát vùng nhớ chứa tham số của system."
        },
        {
          "q": "Vì sao đôi khi dùng execve() thay vì system()?",
          "options": [
            {"text": "execve không thả quyền trong một số kịch bản SUID", "correct": true},
            {"text": "execve dễ tìm địa chỉ hơn", "correct": false},
            {"text": "execve không cần đối số", "correct": false},
            {"text": "system đã bị xóa khỏi libc", "correct": false}
          ],
          "explanation": "system(/bin/sh) có thể bị shell thả quyền; execve kiểm soát tốt hơn."
        },
        {
          "q": "Công thức địa chỉ thực khi có ASLR là?",
          "options": [
            {"text": "Real = Base + Offset", "correct": true},
            {"text": "Real = Base - Offset", "correct": false},
            {"text": "Real = Offset", "correct": false},
            {"text": "Real = Base * Offset", "correct": false}
          ],
          "explanation": "Offset lấy từ file libc, Base từ rò rỉ địa chỉ."
        },
        {
          "q": "readelf/strings hữu ích để làm gì trong tấn công này?",
          "options": [
            {"text": "Tìm offset tĩnh của system và chuỗi \"/bin/sh\"", "correct": true},
            {"text": "Kết nối server", "correct": false},
            {"text": "Debug runtime", "correct": false},
            {"text": "Vượt firewall", "correct": false}
          ],
          "explanation": "Phục vụ tính toán địa chỉ thực khi chạy."
        },
        {
          "q": "ROP chain được xây từ thành phần nào?",
          "options": [
            {"text": "API functions", "correct": false},
            {"text": "Các gadgets kết thúc bằng RET", "correct": true},
            {"text": "Shellcode mới", "correct": false},
            {"text": "Biến môi trường", "correct": false}
          ],
          "explanation": "Gadgets lấy từ mã chương trình/thư viện hiện có."
        },
        {
          "q": "Ghi đè EBP/RBP có thể dẫn tới kỹ thuật nào?",
          "options": [
            {"text": "Stack Pivoting", "correct": true},
            {"text": "Heap Spraying", "correct": false},
            {"text": "Integer Overflow", "correct": false},
            {"text": "Race Condition", "correct": false}
          ],
          "explanation": "Chuyển con trỏ stack tới vùng nhớ do kẻ tấn công kiểm soát."
        }
      ]
    },
    {
      "id": "topic-2",
      "title": "Format String Attack",
      "category": "Tấn công & Lỗ hổng",
      "content": {
        "summary": "Lỗ hổng khi ứng dụng sử dụng input người dùng làm tham số định dạng cho hàm in ấn.",
        "details": [
          {
            "heading": "Nguyên nhân",
            "text": "Lập trình viên viết `printf(user_input)` thay vì `printf(\"%s\", user_input)`."
          },
          {
            "heading": "Khai thác",
            "text": "- Đọc dữ liệu từ Stack: Sử dụng %x (hex) hoặc %s (string).\n- Ghi dữ liệu vào bộ nhớ: Sử dụng %n (ghi số lượng byte đã in vào địa chỉ biến)."
          },
          {
            "heading": "Hậu quả",
            "text": "Rò rỉ thông tin nhạy cảm, Crash chương trình, Thực thi mã (bằng cách ghi đè GOT)."
          }
        ]
      },
      "quiz": [
        {"q": "Hàm nào dễ bị lỗi Format String nhất nếu dùng sai?", "options": [{"text": "puts()", "correct": false}, {"text": "printf()", "correct": true}, {"text": "write()", "correct": false}, {"text": "strcpy()", "correct": false}], "explanation": "printf đọc specifiers từ chuỗi định dạng."},
        {"q": "Specifier nào cho phép GHI vào bộ nhớ?", "options": [{"text": "%s", "correct": false}, {"text": "%x", "correct": false}, {"text": "%n", "correct": true}, {"text": "%p", "correct": false}], "explanation": "%n ghi số ký tự đã in ra vào địa chỉ trỏ tới."},
        {"q": "Chuỗi %x.%x.%x.%x thường dùng để làm gì?", "options": [{"text": "Tràn bộ đệm", "correct": false}, {"text": "Đọc dữ liệu từ Stack", "correct": true}, {"text": "Ghi địa chỉ trả về", "correct": false}, {"text": "Thực thi shellcode", "correct": false}], "explanation": "Dò nội dung stack để lộ thông tin."},
        {"q": "Sai lầm căn bản trong printf(user_input) là gì?", "options": [{"text": "Thiếu buffer trung gian", "correct": false}, {"text": "Thiếu chuỗi định dạng cố định '%s'", "correct": true}, {"text": "Không kiểm tra độ dài", "correct": false}, {"text": "Dùng hàm deprecated", "correct": false}], "explanation": "Chuỗi định dạng phải do lập trình viên kiểm soát."},
        {"q": "%n ghi giá trị gì vào bộ nhớ?", "options": [{"text": "Số tham số truyền vào", "correct": false}, {"text": "Số ký tự đã in", "correct": true}, {"text": "Địa chỉ format string", "correct": false}, {"text": "Null byte", "correct": false}], "explanation": "%n ghi tổng số ký tự đã output."},
        {"q": "Cú pháp Direct Parameter Access là?", "options": [{"text": "%x$n", "correct": false}, {"text": "%$nx", "correct": false}, {"text": "%n$x (ví dụ %4$x)", "correct": true}, {"text": "&n$x", "correct": false}], "explanation": "Chọn tham số theo vị trí n trên stack."},
        {"q": "Cách ghi địa chỉ lớn mà không in hàng tỷ ký tự?", "options": [{"text": "Chia nhỏ ghi bằng %hn/%hhn", "correct": true}, {"text": "%Lx", "correct": false}, {"text": "Kết hợp Buffer Overflow", "correct": false}, {"text": "Không thể", "correct": false}], "explanation": "Ghi từng byte/word vào địa chỉ đích."},
        {"q": "Dùng %s với địa chỉ không hợp lệ gây gì?", "options": [{"text": "In quá nhiều dữ liệu", "correct": false}, {"text": "Segmentation Fault (DoS)", "correct": true}, {"text": "Tràn Stack", "correct": false}, {"text": "Ghi đè EIP", "correct": false}], "explanation": "%s coi giá trị là con trỏ và đọc bộ nhớ."},
        {"q": "Mục tiêu thường gặp tại GOT là gì?", "options": [{"text": "Đọc mã nguồn", "correct": false}, {"text": "Ghi đè địa chỉ hàm để chuyển hướng thực thi", "correct": true}, {"text": "Thay đổi biến môi trường", "correct": false}, {"text": "Tắt ASLR", "correct": false}], "explanation": "Ghi đè entry trỏ tới hàm cần thay thế."},
        {"q": "printf(\"%100x%n\", var) sẽ ghi vào var?", "options": [{"text": "100", "correct": true}, {"text": "10", "correct": false}, {"text": "0", "correct": false}, {"text": "Giá trị hex của 100", "correct": false}], "explanation": "Độ rộng 100 ký tự -> %n ghi 100."},
        {"q": "Phòng chống tốt nhất ở mức mã nguồn?", "options": [{"text": "printf(\"%s\", input)", "correct": true}, {"text": "printf(input)", "correct": false}, {"text": "Dùng cout", "correct": false}, {"text": "Lọc ký tự %", "correct": false}], "explanation": "Chuỗi định dạng phải cố định."},
        {"q": "_FORTIFY_SOURCE giúp ngăn điều gì?", "options": [{"text": "%x đọc stack", "correct": false}, {"text": "Sử dụng %n khi format nằm ở vùng nhớ có thể ghi", "correct": true}, {"text": "Mọi printf", "correct": false}, {"text": "Tự động đổi printf thành puts", "correct": false}], "explanation": "Giảm nguy cơ ghi tùy ý bằng %n."},
        {"q": "Vì sao có thể bypass Canary?", "options": [{"text": "Ghi đè Canary", "correct": false}, {"text": "Đọc giá trị Canary từ stack", "correct": true}, {"text": "Làm Canary ngừng hoạt động", "correct": false}, {"text": "Nhảy qua kiểm tra", "correct": false}], "explanation": "Information leak hỗ trợ bypass."},
        {"q": "%p thường in gì?", "options": [{"text": "Chuỗi ký tự", "correct": false}, {"text": "Giá trị con trỏ dạng Hex", "correct": true}, {"text": "Số nguyên có dấu", "correct": false}, {"text": "Số thực", "correct": false}], "explanation": "In địa chỉ bộ nhớ."},
        {"q": "snprintf có an toàn tuyệt đối trước Format String không?", "options": [{"text": "Có, giới hạn độ dài", "correct": false}, {"text": "Không, nếu format do người dùng kiểm soát", "correct": true}, {"text": "Có, không hỗ trợ %n", "correct": false}, {"text": "Không, gây tràn", "correct": false}], "explanation": "Giới hạn độ dài không loại bỏ lỗi logic format."},
        {"q": "Ý nghĩa kỹ thuật của payload %4$n là?", "options": [{"text": "In 4 ký tự", "correct": false}, {"text": "Ghi số ký tự đã in vào địa chỉ tham số thứ 4", "correct": true}, {"text": "Đọc giá trị thứ 4", "correct": false}, {"text": "Bỏ qua 4 tham số", "correct": false}], "explanation": "Dùng định vị trực tiếp tham số n trên stack."},
        {"q": "Thời điểm lỗ hổng này được công bố rộng rãi?", "options": [{"text": "1988", "correct": false}, {"text": "1999-2000", "correct": true}, {"text": "2010", "correct": false}, {"text": "1970", "correct": false}], "explanation": "Các nghiên cứu nổi bật giai đoạn 1999-2000."},
        {"q": "Xem nội dung tại 0x08048000 bằng Format String thế nào?", "options": [{"text": "Đặt địa chỉ lên stack và dùng %s", "correct": true}, {"text": "Dùng %x liên tục", "correct": false}, {"text": "Dùng %n", "correct": false}, {"text": "Dùng %u", "correct": false}], "explanation": "%s coi tham số là con trỏ đến chuỗi."},
        {"q": "Khác biệt giữa %u và %d khi in từ stack?", "options": [{"text": "%u in số không dấu, hiển thị địa chỉ lớn tốt hơn", "correct": true}, {"text": "%d in số thực", "correct": false}, {"text": "Không khác biệt", "correct": false}, {"text": "%u an toàn hơn", "correct": false}], "explanation": "%u phù hợp cho giá trị không dấu."},
        {"q": "Nhận định đúng về lỗi Format String hiện nay?", "options": [{"text": "Tuyệt chủng", "correct": false}, {"text": "Rất phổ biến ở Web PHP/Java", "correct": false}, {"text": "Hiếm hơn nhưng nghiêm trọng ở IoT/C hoặc phần mềm cũ", "correct": true}, {"text": "Chỉ xảy ra trên Windows", "correct": false}], "explanation": "Vẫn là mối đe dọa trong hệ thống C/C++ và nhúng."}
      ]
    },
    {
      "id": "topic-3",
      "title": "CSRF (Cross-Site Request Forgery)",
      "category": "Tấn công & Lỗ hổng",
      "content": {
        "summary": "Tấn công mượn danh tính người dùng để thực hiện hành động trái phép.",
        "details": [
          {
            "heading": "Cơ chế",
            "text": "Lợi dụng việc trình duyệt tự động gửi Cookie xác thực kèm theo mọi request đến domain đích. Hacker lừa nạn nhân bấm vào link hoặc load ảnh chứa request độc hại (ví dụ: chuyển tiền)."
          },
          {
            "heading": "Phòng chống",
            "text": "- Anti-CSRF Token: Mã bí mật gắn vào form.\n- SameSite Cookie: Ngăn trình duyệt gửi cookie cross-site.\n- Yêu cầu xác thực lại (Re-authentication) cho giao dịch quan trọng."
          }
        ]
      },
      "quiz": [
        {
          "q": "Bản chất của tấn công CSRF là gì?",
          "options": [
            {"text": "Lừa trình duyệt của nạn nhân gửi request không mong muốn đến server.", "correct": true},
            {"text": "Mượn danh tính (cookie) của nạn nhân để thực hiện hành động.", "correct": true},
            {"text": "Đánh cắp mật khẩu nạn nhân.", "correct": false},
            {"text": "Cài virus vào máy nạn nhân.", "correct": false},
            {"text": "Chiếm quyền điều khiển server.", "correct": false},
            {"text": "Đọc dữ liệu nhạy cảm của nạn nhân.", "correct": false},
            {"text": "Tấn công vào cơ sở dữ liệu.", "correct": false}
          ],
          "explanation": "CSRF không đánh cắp thông tin (như XSS), nó 'ép' nạn nhân thực hiện hành động (chuyển tiền, đổi pass) mà nạn nhân không biết."
        },
        {
          "q": "Tại sao Anti-CSRF Token ngăn chặn được CSRF?",
          "options": [
            {"text": "Vì kẻ tấn công không thể biết/đoán được giá trị Token này.", "correct": true},
            {"text": "Vì Token này không được trình duyệt tự động gửi đi (khác với Cookie).", "correct": true},
            {"text": "Vì Token được mã hóa.", "correct": false},
            {"text": "Vì Token thay đổi IP.", "correct": false},
            {"text": "Vì Token chặn JavaScript.", "correct": false},
            {"text": "Vì Token làm chậm request.", "correct": false},
            {"text": "Vì Token chỉ dùng cho admin.", "correct": false}
          ],
          "explanation": "Kẻ tấn công có thể giả mạo request, nhưng không thể điền đúng trường 'csrf_token' trong form vì họ không đọc được nội dung trang web của nạn nhân."
        }
      ]
    },
    {
      "id": "topic-4",
      "title": "XSS (Cross-Site Scripting)",
      "category": "Tấn công & Lỗ hổng",
      "content": {
        "summary": "Chèn mã script độc hại (thường là JavaScript) vào trang web để thực thi trên trình duyệt người dùng.",
        "details": [
          {
            "heading": "Phân loại",
            "text": "- Stored XSS: Mã độc lưu trong CSDL.\n- Reflected XSS: Mã độc phản hồi từ URL.\n- DOM-based XSS: Lỗ hổng trong xử lý JavaScript phía client."
          },
          {
            "heading": "Phòng chống",
            "text": "- Output Encoding: Mã hóa ký tự đặc biệt thành HTML entities.\n- CSP (Content Security Policy): Giới hạn nguồn chạy script."
          }
        ]
      },
      "quiz": [
        {
          "q": "XSS (Cross-Site Scripting) cho phép kẻ tấn công làm gì?",
          "options": [
            {"text": "Thực thi mã script độc hại (JavaScript) trên trình duyệt của nạn nhân.", "correct": true},
            {"text": "Thao túng giao diện hoặc đánh cắp thông tin phiên làm việc của người dùng.", "correct": true},
            {"text": "Thực thi lệnh trên máy chủ web.", "correct": false},
            {"text": "Truy cập trực tiếp vào cơ sở dữ liệu.", "correct": false},
            {"text": "Tấn công từ chối dịch vụ server.", "correct": false},
            {"text": "Đọc file hệ thống của server.", "correct": false},
            {"text": "Phá khóa mật khẩu admin.", "correct": false}
          ],
          "explanation": "XSS là lỗ hổng Client-side, mã độc chạy trên máy của người dùng, không phải trên server."
        }
      ]
    },
    {
      "id": "topic-5",
      "title": "SQL Injection (SQLi)",
      "category": "Tấn công & Lỗ hổng",
      "content": {
        "summary": "Can thiệp vào câu lệnh SQL của ứng dụng thông qua dữ liệu đầu vào.",
        "details": [
          {
            "heading": "Kỹ thuật",
            "text": "- Union-based: Gộp kết quả.\n- Error-based: Khai thác thông báo lỗi.\n- Blind SQLi: Dựa trên phản hồi Đúng/Sai hoặc Thời gian."
          },
          {
            "heading": "Phòng chống",
            "text": "Sử dụng Prepared Statements (Truy vấn tham số hóa) là biện pháp hiệu quả nhất."
          }
        ]
      },
      "quiz": [
        {
          "q": "Biện pháp phòng chống SQL Injection hiệu quả nhất?",
          "options": [
            {"text": "Sử dụng Prepared Statements (Truy vấn tham số hóa).", "correct": true},
            {"text": "Sử dụng các thư viện ORM (Object-Relational Mapping) hỗ trợ binding.", "correct": true},
            {"text": "Lọc dấu nháy đơn.", "correct": false},
            {"text": "Dùng WAF.", "correct": false},
            {"text": "Mã hóa dữ liệu.", "correct": false},
            {"text": "Đổi tên bảng.", "correct": false},
            {"text": "Dùng NoSQL.", "correct": false}
          ],
          "explanation": "Prepared Statements gửi câu lệnh và dữ liệu riêng biệt. Input '1 OR 1=1' sẽ được coi là một chuỗi văn bản thuần túy, không phải lệnh."
        }
      ]
    },
    {
      "id": "topic-6",
      "title": "Sqlmap",
      "category": "Công cụ",
      "content": {
        "summary": "Công cụ kiểm thử xâm nhập tự động mã nguồn mở chuyên khai thác SQL Injection.",
        "details": [
          {
            "heading": "Chức năng",
            "text": "Tự động phát hiện lỗi, xác định loại DB, trích xuất dữ liệu (dump), và chiếm quyền (os-shell)."
          },
          {
            "heading": "Lệnh cơ bản",
            "text": "-u (URL), --dbs (List DBs), -D (Chọn DB), -T (Chọn Table), --dump (Lấy dữ liệu)."
          }
        ]
      },
      "quiz": [
        {
          "q": "Lệnh --dbs trong Sqlmap dùng để làm gì?",
          "options": [
            {"text": "Liệt kê danh sách các cơ sở dữ liệu (Databases) hiện có trên server.", "correct": true},
            {"text": "Enumerates available databases.", "correct": true},
            {"text": "Xóa database.", "correct": false},
            {"text": "Tạo database mới.", "correct": false},
            {"text": "Sao lưu database.", "correct": false},
            {"text": "Đổi tên database.", "correct": false},
            {"text": "Kết nối database.", "correct": false}
          ],
          "explanation": "Bước đầu tiên trong quá trình trích xuất dữ liệu (Enumeration)."
        }
      ]
    },
    {
      "id": "topic-7",
      "title": "File Upload Vulnerability",
      "category": "Tấn công & Lỗ hổng",
      "content": {
        "summary": "Lỗ hổng cho phép tải lên tệp tin độc hại (như web shell) để thực thi mã từ xa.",
        "details": [
          {
            "heading": "Nguy cơ",
            "text": "RCE (Remote Code Execution) - Chiếm quyền điều khiển máy chủ."
          },
          {
            "heading": "Phòng chống",
            "text": "- Whitelist Extension (Chỉ cho phép ảnh/pdf).\n- Đổi tên file ngẫu nhiên.\n- Lưu file ngoài thư mục web root.\n- Tắt quyền thực thi trong thư mục upload."
          }
        ]
      },
      "quiz": [
        {
          "q": "Nguy cơ lớn nhất của lỗ hổng File Upload là gì?",
          "options": [
            {"text": "Remote Code Execution (RCE).", "correct": true},
            {"text": "Kẻ tấn công tải lên Web Shell và chiếm quyền server.", "correct": true},
            {"text": "XSS.", "correct": false},
            {"text": "SQL Injection.", "correct": false},
            {"text": "Làm đầy ổ cứng.", "correct": false},
            {"text": "Mất giao diện web.", "correct": false},
            {"text": "Lộ email.", "correct": false}
          ],
          "explanation": "Nếu file độc hại (php, asp) được thực thi, hacker có quyền tương đương với web server."
        }
      ]
    },
    {
      "id": "topic-8",
      "title": "Directory Traversal",
      "category": "Tấn công & Lỗ hổng",
      "content": {
        "summary": "Tấn công leo thang thư mục để truy cập trái phép các tệp tin hệ thống.",
        "details": [
          {
            "heading": "Kỹ thuật",
            "text": "Sử dụng chuỗi `../` (dot-dot-slash) để lùi về thư mục cha. Ví dụ: `../../etc/passwd`."
          },
          {
            "heading": "Phòng chống",
            "text": "- Sử dụng hàm `basename()` để lọc đường dẫn.\n- Validate Input (Whitelist ký tự).\n- Cấu hình quyền truy cập file chặt chẽ."
          }
        ]
      },
      "quiz": [
        {
          "q": "Chuỗi ký tự nào là đặc trưng của tấn công Directory Traversal?",
          "options": [
            {"text": "../ (Dot dot slash).", "correct": true},
            {"text": "..\\ (trên Windows).", "correct": true},
            {"text": "<script>", "correct": false},
            {"text": "UNION SELECT", "correct": false},
            {"text": "OR 1=1", "correct": false},
            {"text": "{{7*7}}", "correct": false},
            {"text": "alert(1)", "correct": false}
          ],
          "explanation": "Lệnh này nghĩa là 'lùi về thư mục cha' trong hầu hết các hệ điều hành."
        }
      ]
    },
    {
      "id": "topic-9",
      "title": "Firewall & IDS",
      "category": "Hạ tầng",
      "content": {
        "summary": "Các hệ thống bảo vệ mạng.",
        "details": [
          {
            "heading": "Firewall",
            "text": "Kiểm soát lưu lượng ra/vào dựa trên luật (IP, Port). Có Stateless và Stateful."
          },
          {
            "heading": "IDS/IPS",
            "text": "- IDS (Detection): Phát hiện và cảnh báo tấn công.\n- IPS (Prevention): Phát hiện và tự động chặn tấn công."
          }
        ]
      },
      "quiz": [
        {
          "q": "Sự khác biệt chính giữa IDS và IPS là gì?",
          "options": [
            {"text": "IDS chỉ phát hiện và cảnh báo (Alert), IPS có thể tự động chặn (Block).", "correct": true},
            {"text": "IDS là bị động (passive), IPS là chủ động (active).", "correct": true},
            {"text": "IDS đắt hơn.", "correct": false},
            {"text": "IPS chỉ là phần mềm.", "correct": false},
            {"text": "IDS chặn, IPS báo.", "correct": false},
            {"text": "Giống hệt nhau.", "correct": false},
            {"text": "IDS cho nội bộ, IPS cho internet.", "correct": false}
          ],
          "explanation": "IDS giống camera quan sát, IPS giống bảo vệ có vũ trang."
        }
      ]
    },
    {
      "id": "topic-10",
      "title": "Traditional Ciphers",
      "category": "Mật mã học",
      "content": {
        "summary": "Các phương pháp mã hóa cổ điển.",
        "details": [
          {
            "heading": "Substitution (Thay thế)",
            "text": "Thay ký tự này bằng ký tự khác. Ví dụ: Caesar (dịch chuyển k), Vigenère (đa bảng)."
          },
          {
            "heading": "One-Time Pad",
            "text": "An toàn tuyệt đối nếu khóa ngẫu nhiên, dài bằng tin nhắn và chỉ dùng 1 lần."
          }
        ]
      },
      "quiz": [
        {
          "q": "Điểm yếu chí mạng của Mã hóa Caesar là gì?",
          "options": [
            {"text": "Dễ bị phá vỡ bằng Phân tích tần suất (Frequency Analysis).", "correct": true},
            {"text": "Các chữ cái phổ biến trong ngôn ngữ sẽ xuất hiện với tần suất tương tự trong bản mã.", "correct": true},
            {"text": "Khóa quá ngắn.", "correct": false},
            {"text": "Dễ bị Brute-force.", "correct": false},
            {"text": "Không dùng máy tính.", "correct": false},
            {"text": "Khóa quá dài.", "correct": false},
            {"text": "Không hỗ trợ số.", "correct": false}
          ],
          "explanation": "Biểu đồ tần suất của bản mã có hình dạng giống hệt bản rõ, chỉ bị dịch chuyển."
        }
      ]
    },
    {
      "id": "topic-11",
      "title": "Transposition Ciphers",
      "category": "Mật mã học",
      "content": {
        "summary": "Mã hóa bằng cách hoán vị (đổi chỗ) các ký tự mà không thay đổi bản thân ký tự.",
        "details": [
          {
            "heading": "Ví dụ",
            "text": "Rail Fence (Zic-zac), Columnar Transposition (Viết theo dòng, đọc theo cột)."
          },
          {
            "heading": "Đặc điểm",
            "text": "Giữ nguyên tần suất ký tự của bản rõ -> Dễ bị phát hiện."
          }
        ]
      },
      "quiz": [
        {
          "q": "Sự khác biệt chính giữa Substitution và Transposition Cipher?",
          "options": [
            {"text": "Substitution thay đổi ký tự, Transposition thay đổi vị trí ký tự.", "correct": true},
            {"text": "Một bên đổi 'A' thành 'X', một bên đổi chỗ 'A' đứng đầu xuống cuối.", "correct": true},
            {"text": "Giống hệt nhau.", "correct": false},
            {"text": "Transposition an toàn hơn.", "correct": false},
            {"text": "Substitution dùng số.", "correct": false},
            {"text": "Transposition dùng bit.", "correct": false},
            {"text": "Transposition là hàm băm.", "correct": false}
          ],
          "explanation": "Substitution làm mất nhận dạng ký tự. Transposition làm mất trật tự ký tự."
        }
      ]
    },
    {
      "id": "topic-12",
      "title": "Cryptographic Hashes",
      "category": "Mật mã học",
      "content": {
        "summary": "Hàm băm một chiều, biến đầu vào bất kỳ thành chuỗi cố định.",
        "details": [
          {
            "heading": "Tính chất",
            "text": "Kháng tiền ảnh (One-way), Kháng va chạm (Collision resistance), Hiệu ứng thác đổ."
          },
          {
            "heading": "Thuật toán",
            "text": "- MD5: Đã hỏng (Collision).\n- SHA-256: Chuẩn an toàn hiện nay."
          }
        ]
      },
      "quiz": [
        {
          "q": "Tại sao MD5 được coi là 'đã hỏng' (broken)?",
          "options": [
            {"text": "Vì đã tìm ra cách tạo va chạm (Collision) nhanh chóng.", "correct": true},
            {"text": "Có thể tạo 2 file khác nhau có cùng hash MD5.", "correct": true},
            {"text": "Vì nó quá chậm.", "correct": false},
            {"text": "Vì nó quá dài.", "correct": false},
            {"text": "Vì nó giải mã được.", "correct": false},
            {"text": "Vì nó tốn điện.", "correct": false},
            {"text": "Vì nó cũ.", "correct": false}
          ],
          "explanation": "Va chạm hash cho phép giả mạo chữ ký số và nội dung file."
        }
      ]
    },
    {
      "id": "topic-13",
      "title": "MAC & HMAC",
      "category": "Mật mã học",
      "content": {
        "summary": "Cơ chế xác thực thông điệp dùng khóa bí mật.",
        "details": [
          {
            "heading": "MAC",
            "text": "Đảm bảo tính Toàn vẹn và Xác thực."
          },
          {
            "heading": "HMAC",
            "text": "Sử dụng hàm băm lồng nhau (Hash-based) để chống tấn công mở rộng độ dài (Length Extension Attack)."
          }
        ]
      },
      "quiz": [
        {
          "q": "Sự khác biệt chính giữa MAC và Hash (băm) là gì?",
          "options": [
            {"text": "MAC sử dụng một khóa bí mật (Secret Key), Hash thì không.", "correct": true},
            {"text": "Ai cũng tính được Hash, nhưng chỉ người có khóa mới tính được MAC.", "correct": true},
            {"text": "MAC dài hơn Hash.", "correct": false},
            {"text": "Hash an toàn hơn MAC.", "correct": false},
            {"text": "MAC dùng để nén.", "correct": false},
            {"text": "Hash dùng khóa công khai.", "correct": false},
            {"text": "Không có khác biệt.", "correct": false}
          ],
          "explanation": "Hash kiểm tra lỗi ngẫu nhiên hoặc toàn vẹn công khai. MAC kiểm tra sự giả mạo có chủ đích từ người không có khóa."
        }
      ]
    },
    {
      "id": "topic-14",
      "title": "Yescrypt",
      "category": "Mật mã học",
      "content": {
        "summary": "Hàm băm mật khẩu hiện đại, kháng GPU/ASIC.",
        "details": [
          {
            "heading": "Đặc điểm",
            "text": "Memory-hard (tốn RAM), dựa trên Scrypt nhưng cải tiến. Là chuẩn mặc định trên Linux hiện đại."
          },
          {
            "heading": "Mục đích",
            "text": "Làm chậm quá trình crack mật khẩu bằng phần cứng chuyên dụng."
          }
        ]
      },
      "quiz": [
        {
          "q": "Đặc tính 'Memory-hard' của Yescrypt có tác dụng gì?",
          "options": [
            {"text": "Buộc kẻ tấn công phải dùng nhiều RAM để tính toán hash.", "correct": true},
            {"text": "Làm giảm hiệu quả của GPU/FPGA (vốn có ít bộ nhớ cho mỗi nhân) khi tấn công Brute-force.", "correct": true},
            {"text": "Giúp chạy nhanh hơn.", "correct": false},
            {"text": "Tiết kiệm RAM.", "correct": false},
            {"text": "Tăng tốc độ mạng.", "correct": false},
            {"text": "Giảm dung lượng đĩa.", "correct": false},
            {"text": "Tương thích ngược.", "correct": false}
          ],
          "explanation": "Tấn công mật khẩu trên GPU dựa vào khả năng tính toán song song cực lớn nhưng bộ nhớ hạn chế. Yescrypt đánh vào điểm yếu này."
        }
      ]
    },
    {
      "id": "topic-15",
      "title": "bcrypt",
      "category": "Mật mã học",
      "content": {
        "summary": "Hàm băm mật khẩu chuẩn công nghiệp dựa trên Blowfish.",
        "details": [
          {
            "heading": "Tính năng",
            "text": "Adaptive Hashing (Có thể điều chỉnh Cost Factor để làm chậm thuật toán theo thời gian). Tích hợp sẵn Salt."
          },
          {
            "heading": "Ưu điểm",
            "text": "Chống Brute-force hiệu quả nhờ tốc độ chậm tùy chỉnh."
          }
        ]
      },
      "quiz": [
        {
          "q": "Cost Factor (ví dụ 10, 12) trong bcrypt biểu thị điều gì?",
          "options": [
            {"text": "Số vòng lặp là 2 mũ Cost (2^10, 2^12).", "correct": true},
            {"text": "Tăng cost lên 1 đơn vị nghĩa là thời gian tính toán tăng gấp đôi.", "correct": true},
            {"text": "Số giây tính toán.", "correct": false},
            {"text": "Độ dài mật khẩu.", "correct": false},
            {"text": "Số ký tự salt.", "correct": false},
            {"text": "Phiên bản phần mềm.", "correct": false},
            {"text": "Độ an toàn tuyệt đối.", "correct": false}
          ],
          "explanation": "Giúp thuật toán 'thích nghi' (adaptive) với tốc độ phần cứng tăng dần theo thời gian."
        }
      ]
    },
    {
      "id": "topic-16",
      "title": "DES (Data Encryption Standard)",
      "category": "Mật mã học",
      "content": {
        "summary": "Chuẩn mã hóa khối cũ (1977), sử dụng mạng Feistel.",
        "details": [
          {
            "heading": "Thông số",
            "text": "Block: 64-bit. Key: 56-bit. Vòng: 16."
          },
          {
            "heading": "Trạng thái",
            "text": "Không an toàn do khóa quá ngắn (dễ bị brute-force). Đã bị thay thế bởi AES."
          }
        ]
      },
      "quiz": [
        {
          "q": "Tại sao DES được coi là không an toàn hiện nay?",
          "options": [
            {"text": "Không gian khóa quá nhỏ (2^56), dễ bị tấn công vét cạn (Brute-force).", "correct": true},
            {"text": "Máy tính hiện đại có thể dò ra khóa trong vài giờ.", "correct": true},
            {"text": "Thuật toán bị lộ.", "correct": false},
            {"text": "S-box bị hỏng.", "correct": false},
            {"text": "Không hỗ trợ Wifi.", "correct": false},
            {"text": "Quá chậm.", "correct": false},
            {"text": "Bị cài backdoor.", "correct": false}
          ],
          "explanation": "Kích thước khóa 56-bit là quá nhỏ so với sức mạnh tính toán ngày nay."
        }
      ]
    },
    {
      "id": "topic-17",
      "title": "AES (Advanced Encryption Standard)",
      "category": "Mật mã học",
      "content": {
        "summary": "Chuẩn mã hóa đối xứng hiện đại, an toàn và hiệu quả.",
        "details": [
          {
            "heading": "Thông số",
            "text": "Block: 128-bit. Key: 128/192/256-bit. Cấu trúc: SPN."
          },
          {
            "heading": "Hoạt động",
            "text": "Gồm 4 bước: SubBytes, ShiftRows, MixColumns, AddRoundKey."
          }
        ]
      },
      "quiz": [
        {
          "q": "Kích thước khối (Block Size) của AES là bao nhiêu?",
          "options": [
            {"text": "128 bits.", "correct": true},
            {"text": "Cố định là 128 bit cho mọi độ dài khóa.", "correct": true},
            {"text": "64 bits.", "correct": false},
            {"text": "256 bits.", "correct": false},
            {"text": "512 bits.", "correct": false},
            {"text": "Tùy chọn.", "correct": false},
            {"text": "32 bits.", "correct": false}
          ],
          "explanation": "Dù khóa có thể là 128, 192 hay 256 bit, nhưng khối dữ liệu xử lý luôn là 128 bit."
        }
      ]
    },
    {
      "id": "topic-18",
      "title": "Block Cipher Modes",
      "category": "Mật mã học",
      "content": {
        "summary": "Các chế độ vận hành để mã hóa dữ liệu dài hơn một khối.",
        "details": [
          {
            "heading": "Các chế độ",
            "text": "- ECB: Không an toàn (lộ mẫu).\n- CBC: An toàn, tuần tự, cần IV.\n- GCM: An toàn, nhanh (song song), có xác thực (AEAD)."
          }
        ]
      },
      "quiz": [
        {
          "q": "ECB (Electronic Codebook) có điểm yếu gì?",
          "options": [
            {"text": "Các khối bản rõ giống nhau sẽ sinh ra khối bản mã giống nhau.", "correct": true},
            {"text": "Làm lộ mẫu hình dữ liệu (ví dụ: logo chim cánh cụt vẫn nhìn thấy được sau khi mã hóa).", "correct": true},
            {"text": "Tốc độ chậm.", "correct": false},
            {"text": "Khó cài đặt.", "correct": false},
            {"text": "Cần IV.", "correct": false},
            {"text": "Làm hỏng dữ liệu.", "correct": false},
            {"text": "Không hỗ trợ AES.", "correct": false}
          ],
          "explanation": "ECB mã hóa từng khối độc lập mà không có sự ngẫu nhiên hóa (IV), không che giấu được cấu trúc dữ liệu."
        }
      ]
    },
    {
      "id": "topic-19",
      "title": "RSA & PKI",
      "category": "Mật mã học",
      "content": {
        "summary": "Hệ thống mật mã khóa công khai và hạ tầng chứng chỉ số.",
        "details": [
          {
            "heading": "RSA",
            "text": "Dựa trên bài toán phân tích thừa số nguyên tố. Dùng Public Key để mã hóa/verify, Private Key để giải mã/ký."
          },
          {
            "heading": "PKI",
            "text": "Hệ thống CA (Certificate Authority) để xác thực danh tính của chủ sở hữu Public Key (tránh Man-in-the-Middle)."
          }
        ]
      },
      "quiz": [
        {
          "q": "Trong RSA, nếu Alice muốn gửi tin nhắn BÍ MẬT cho Bob, Alice dùng khóa nào để mã hóa?",
          "options": [
            {"text": "Public Key của Bob.", "correct": true},
            {"text": "Để chỉ Bob (người giữ Private Key) mới giải mã được.", "correct": true},
            {"text": "Private Key của Alice.", "correct": false},
            {"text": "Public Key của Alice.", "correct": false},
            {"text": "Private Key của Bob.", "correct": false},
            {"text": "Khóa phiên.", "correct": false},
            {"text": "Khóa CA.", "correct": false}
          ],
          "explanation": "Mã hóa bằng khóa công khai của người nhận đảm bảo tính bảo mật (Confidentiality)."
        }
      ]
    },
    {
      "id": "topic-20",
      "title": "Diffie-Hellman & HTTPS",
      "category": "Giao thức",
      "content": {
        "summary": "Giao thức trao đổi khóa và bảo mật web.",
        "details": [
          {
            "heading": "Diffie-Hellman",
            "text": "Cho phép 2 bên tạo khóa chung qua kênh không an toàn (dựa trên Logarit rời rạc)."
          },
          {
            "heading": "HTTPS (TLS)",
            "text": "Kết hợp: RSA/PKI (Xác thực) + DH (Trao đổi khóa) + AES (Mã hóa dữ liệu) + HMAC (Toàn vẹn)."
          }
        ]
      },
      "quiz": [
        {
          "q": "Mục đích chính của giao thức Diffie-Hellman là gì?",
          "options": [
            {"text": "Trao đổi khóa bí mật chung qua kênh không an toàn.", "correct": true},
            {"text": "Hai bên thống nhất một Shared Secret mà người nghe lén không biết.", "correct": true},
            {"text": "Mã hóa tin nhắn.", "correct": false},
            {"text": "Ký số.", "correct": false},
            {"text": "Xác thực danh tính.", "correct": false},
            {"text": "Nén dữ liệu.", "correct": false},
            {"text": "Băm mật khẩu.", "correct": false}
          ],
          "explanation": "DH giải quyết vấn đề phân phối khóa của mật mã đối xứng."
        }
      ]
    },
    {
      "id": "topic-21",
      "title": "JWT (JSON Web Token)",
      "category": "Giao thức",
      "content": {
        "summary": "Chuẩn token dùng cho xác thực phi trạng thái (Stateless).",
        "details": [
          {
            "heading": "Cấu trúc",
            "text": "Header.Payload.Signature (Base64Url encoded)."
          },
          {
            "heading": "Lưu ý",
            "text": "Payload không được mã hóa (chỉ encode), không để lộ thông tin mật. Signature giúp chống sửa đổi."
          }
        ]
      },
      "quiz": [
        {
          "q": "Dữ liệu trong Payload của JWT có được mã hóa an toàn không?",
          "options": [
            {"text": "Không, nó chỉ được Encode Base64Url.", "correct": true},
            {"text": "Bất kỳ ai có token đều có thể giải mã (decode) để đọc nội dung.", "correct": true},
            {"text": "Có, được mã hóa AES.", "correct": false},
            {"text": "Có, được mã hóa RSA.", "correct": false},
            {"text": "Chỉ server đọc được.", "correct": false},
            {"text": "Được băm MD5.", "correct": false},
            {"text": "Ẩn đi.", "correct": false}
          ],
          "explanation": "Base64 là mã hóa dạng hiển thị (Encoding), không phải mã hóa bảo mật (Encryption). Ai cũng có thể decode."
        }
      ]
    }
  ]
}